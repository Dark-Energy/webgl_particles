Создавая систему частиц, я использовал обычную схему, когда объект содержит массив частиц, возможно, набор изучателей (emitter) и воздействователей (affector). На каждом цикле выполняется интеграция, вычисляются новые скорости и положения частия. Затем всё это загружается в видеокарту для отрисовки. Внутри класса был объект типа Points, который занимался отрисовкой. Я придумал, как сохранять параметры в JSON и загружать их оттуда. Поскольку  излучатели и влиятели должны расширяться, я создал систему фабрик. Каждый из них сохраняет своё имя (тип). Когда загрузчик видит этот тип, он обращается к фабрике. Фабрика это просто словарь пар вида (имя класса, конструктор). И Фабрика возвращает конструктор, который загрузчик вызывает и передаёт ему параметры. Вот и всё. 

К счастью, в JavaScript можно вызывать конструктор, не зная его типа. В языке с типизацией типа Си++ пришлось бы создавать промеждуточный класс Fabric, наследовать от него разные Fabric_Point_Emitter и внутри него делать 
return new Point_Emitter(params)


Но как всё это связать с системой сохранения сцены, которая уже есть в движке? Там всё плохо. Главный метод, сохраняющий сцену в json находится в базовом классе Object3D. Что уже плохо. Он знает слишком многое для своего положения. Там ещё находится много закрученных методов, которые используются какие-то вычисления с meta и cache, а также проверяют, не является ли данный объект корнем иерерхии. Я до конца не разобрался в этом аду. Загрузку выполняет один большой оператор switch(type). 

На мой взгляд, здесь должны были быть фабрики и классы-сохранятели (serializator), либо записывать себя должен был каждый класс в отдельности. Полученную схему невозможно обновлять и расширять. Это просто хак. 

Тогда я наследовал от Points свой класс Particle_Points, который использовал метод toJSON из объекта Object3D и назначал type="Particles_Points". Таким образом он сохранял только трансформации и положение в иерархии. Затем, после загрузки сцены и систем частиц, я брал объекты Particles_Points, вложенные в частицы и вставлял их на нужные места в графе сцены. А пустышки удалял. 

Для этого я активно использовал moncky patching. 

Заменой объектов занимался метод

THREE.Object3D.prototype.replace_object_with_this


Записью объектов занималась целая примесь

var Object3D_Serialization_Mixin = 

Гланой целью было не записывать материалы и геометрию для Particles_Points.
        if (this.type !== "particles_points")
        {
        
        
Заодно я добавил в начало метода вызов

        this.updateMatrixWorld(true); 

дело в том, что иногда в json записывается единичная матрица и все трансформации пропадают.         

Также в ShaderMaterial есть баг. Uniform don't convert to json, even just to copy, they just assign
		var data = Material.prototype.toJSON.call( this, meta );
		data.uniforms = this.uniforms;
		data.vertexShader = this.vertexShader;
		data.fragmentShader = this.fragmentShader;

This is fail, when uniform contain texture and not gud with shaders (fragment and vertex programms).