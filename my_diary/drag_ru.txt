Перетаскивание объекта мышью


Суть очень простая. Мы засекаем начало перетаскивания в событии mousedown, сохраняем прежние координаты мыши. Затем слушаем событие mousemove. Мы получаем координаты мыши каждый раз, когда она движется и вычитаем новые координаты из ранее запомненных, затем запоминаем новые. Получается вектор движения. Проблема в том, как его транслировать обратно в трёхмерный мир. 

Нельзя просто использовать 
a = get_normalized_screen_coords(oldx, oldy);

ведь он получает беззанковые координаты, а компоненты вектора имеет знак. 

Сначала я засекал координаты мыши в старом и новом положении. Затем брал разность. Полученный вектор переводил в нормализованные координаты

(x / width) * 2 - 1
-(y / height) * 2 - 1

Это не работало. Ведь изначально координаты мыши находились в интервале (0, 800) и (0, 600). А после вычисления вектора скорости, его компоненты получали знак. То есть, чтобы получить корректные значения вектора скорости, надо было перевести координаты мыши в другую систему. 

Здесь у нас два выбора. 

Во-первых, мы можем выбрать такую, где центр находится в центре экрана, а левый верхний угол имеет значение (-400, 300), ось Икс возрастает вправо, а ось Игрек возрастает вверх. 

Во-вторых, мы можем транслировать обе точки в нормализованную систему. 

Поэтому я начал переводить старые и новые координаты в нормализованные и после этого производить вычитание, чтобы получить скорость. 

a = get_normalized_screen_coords(oldx, oldy);
b = get_normalized_sreeen_coords(newx, newy);

c.x = b.x - a.x;
c.y = b.y - a.y;

Впрочем, это тоже бессмысленно. Ведь мы хотим двигать объект в трёхмерном мире, а получаем всего лишь вектор смещения, который находится на плоскости экрана. Неважно, какие мы используем координаты - беззнаковые, знаковые или нормализованные. 

Итак, нам придётся применить обратное проецирование. То есть сперва умножить наши значения на матрицу, обратную проекции и на матрицу, обратную матрицы камеры. Попутно мы можем также получить значение Зет, выполнив проективное деление. Вопрос в том, куда это нас приведёт. В данный момент я понятия не имею, что находится в соот-щей ячейке обратной матрицы проекции. 

В результате мы можем спроецировать обратно либо вектор смещения, либо обе точки на экране и потом уже вычислить вектор смещения. 

Таким образом я проецировал две точки с экрана в трёхмерный мир. Внутри этой функции находится вызов метода THREE.Vector3.unproject(camera). Этот метод сначала перемножает обратную матрицу проекции на обратную матрицу камеры, умножает на неё вектор, а затем выполняет проективное деление. 

Вопрос был в том, куда именно проецируется вектор? Насколько я понял, на дальнюю плоскость отсечения. Впрочем, это дело поправимое. 

a  = Engine.Mouse_Intersector.unproject(a, self.main_camera);
b  = Engine.Mouse_Intersector.unproject(b, self.main_camera);

После вычитания, координата Зет становилась нулевой. А что было бы с проекцией вектора смещения? 

            var vector = new THREE.Vector3();
            //vector = (b - a).normalize()
            vector.copy(b).sub(a).normalize();
            self.drag_object.position.y += vector.y;
            self.drag_object.position.x += vector.x;

К сожалению, это привело к тому, что объект начал двигаться стремительно быстро, убегая от указателя мыши. Размеры вектора, даже после нормализации, были слишком большими. Скорость движения явно должна быть меньше единичной. Как же её посчитать?

Действительно, нормализованная скорость была для объекта слишком большой. Возьмём примеры векторов единичной длины:

(1, 0, 0)
(0, 1, 0),
(0.7, 0.7, 0)

Чему это будет равно в экранном мире после прекции? 
А ведь зачастую нам надо сдвинуть объект всего лишь на пару пикселей по экрану. 
Попробуем убрать нормлаизацию. 

Увы, всё оказалось намного хуже. Скорость стала даже в разы больше!

Тогда я взял два вектора уже в нормализованных координатах, вычел старую позицию из новой и вычислил её длину. Я использовал её как множитель скорости движения. Теперь скорость перемещения объекта стала вообще микроскопической, тысячные доли. 

            var a = Engine.Mouse_Intersector.get_normalized_screen_coords(self.canvas, oldx, oldy);
            var b = Engine.Mouse_Intersector.get_normalized_screen_coords(self.canvas, newx, newy);
            x = b.x - a.x;
            y = b.y - a.y;
            var len = Math.sqrt(x*x + y*y);

            a  = Engine.Mouse_Intersector.unproject(a, self.main_camera);
            b  = Engine.Mouse_Intersector.unproject(b, self.main_camera);
            
            var vector = new THREE.Vector3();
            vector.copy(b).sub(a).normalize().multiplyScalar(len);
            
            self.drag_object.position.y += vector.y;
            self.drag_object.position.x += vector.x;


Но что если передвинуть вычисление длины вектора скорости после его проецирования?


        function get_unproject_velocity(a, b, camera)
        {
            var r1 = new THREE.Vector3();
            r1 = a.clone();
            var r2 = new THREE.Vector3();
            r2 = b.clone();
            r1.z = 0;
            r2.z = 0;
            r1.unproject(camera);
            r2.unproject(camera);
            r2.sub(r1);
            console.log("unproject velocity ", r2);
        }

        
        где a, b взяты в нормализованных экранных координатах. Величины координат получаются вообще три нуля после запятой. 
     
    console.log("unproject velocity ", get_unproject_velocity(a, b, self.main_camera));
    
    Если же вычислять скорость до нормализации, то длина вектора получается вообще космической - единицы 2, 3, 4. 
    
        
            function drag(event)
        {
            newx = event.clientX;
            newy = event.clientY;
            //var x = newx - oldx;
            //var y = newy - oldy;
            //var len = Math.sqrt(x*x + y*y);
            //console.log("screen velocity", x, y, len);
            
            var a = Engine.Mouse_Intersector.get_normalized_screen_coords(self.canvas, oldx, oldy);
            var b = Engine.Mouse_Intersector.get_normalized_screen_coords(self.canvas, newx, newy);
            //console.log("old ", a, "new ", b);
            var x = b.x - a.x;
            var y = b.y - a.y;
            var len = Math.sqrt(x*x + y*y);
            //console.log("normalized screen vector", x,y, len);
            
            //unproject and transform to world space vectors
            a  = Engine.Mouse_Intersector.unproject(a, self.main_camera);
            b  = Engine.Mouse_Intersector.unproject(b, self.main_camera);
            
            //vector = (b-a).normalize();
            var vector = new THREE.Vector3();
            vector.copy(b).sub(a).normalize().multiplyScalar(len);
            
            //self.drag_object.position.y += vector.y;
            //self.drag_object.position.x += vector.x;
            //console.log("world velocity vector ", vector, "length", vector.length());
            
            console.log(self.drag_object.position, b);
            self.drag_object.position.y = b.y;
            self.drag_object.position.x = b.x;
            
            
            oldx = newx;
            oldy = newy;
        }

            
            
Значит, надо как-то изменить это, как-то вычислить обратную проекцию длины вектора. Но куда? На ближней плоскости эта длина будет одной, на дальней плоскоскости она будет огромной. Значит, надо спроецировать длину вектора (или сам вектор) на плоскость, где катается наш шарик. 


        
Во-первых, простая проверка показывает, что обе точки, будучи распроецированы оказываются параллелльны оси экранной плоскости. В нашем случае это минус Зет. Обе точки указывают далеко-далеко по оси Зет и фиг знает куда по осям Икс и Игрек. В любом случае, если приставить этот вектор к началу координат, то он будет показывать фиг знает куда. Ну да, определённо, если объект был слева, то и вектор будет указывать куда-то влево. Если объект был вверху, то и вектор укажет вверх. Только вот куда?        

А где мы собираемся двигать наши сферы? В пределах одной плосоксти sphere_plane. Она параллельна экранной плоскости и одноврменно дальней плоскости отсечения, куда проециуются точки, указанные мышью. О, вот это открытие. 

Значит, все перемещения, все вектора так или иначе проходят одинаковыми по направлениям с экрана в нормализованное пространство, затем на экранную плоскость камеры и дальше на дальнюю плоскость отсечения. Нас волнует только длина вектора, ибо она определяет скорость перемещения сферы. 

Как спроецировать вектор перемещения на sphere_plane? В принципе, для этого должна быть какая-то матрица. Эта плоскость также параллельна экранной плоскости камеры и дальней плоскости отсечения. Также её нормаль указыват в направлении взгляда камеры. В нашем случае это (0, 0, -1), вдоль оси Зет в отрицательном её направлении. 

ВЫполнив скалярное умножение позиции сферы (объекта) с нормалью плоскости, мы получим расстояние плоскости до начала координат sphere_dist. Таким образом, у нас будет полное уравнение плоскости, которое можно использовать для разных целей. 

Что ж, проецируем в реальный мир точку Б. Затем вычтем её из позиции камеры, нормализуем полученный вектор. Найдём его скалярное произведение с нормалью плоскостью sphere_plane. Умножим это значение на sphere_dist. Вот, мы на плоскости, где лежит наша сфера. 

Где мы возьмём нормаль экранной плоскости? Из матрицы вида камеры. 

В THREE.camera есть матрица matrixWorldInverse, которая как бы отвечает за матрицу вида. На самом деле это просто обратная матрица локальных преобразований. Я понятия не имею, когда она изменяется и как. А вот, нашёл, это делается ажно в функции render в файле WGLREnderer. Там совершенно жуткой кусок говнокода. У меня аж все волосы встали на жопе. 


У матрицы есть метод
	extractBasis: function ( xAxis, yAxis, zAxis ) {

		xAxis.setFromMatrixColumn( this, 0 );
		yAxis.setFromMatrixColumn( this, 1 );
		zAxis.setFromMatrixColumn( this, 2 );

		return this;

	}, 
    
getInverse(matrix)  делает текущую матрицу обратной для переданной

Выглядит это так
		camera.matrixWorldInverse.getInverse( camera.matrixWorld );
        
        Matrix4 m = new THREE.Matrix4();
        m.getInverse(camera.matrixWorld);
        var axis1 = new THREE.Vector3();
        var axis2 = new THREE.Vector3(); 
        var axis3 = new THREE.Vector3();
        m.extractBasis(axis1, axis2, axis3);
        
        console.log(axis3);
        
-------

Короче, я решил придумать, как перетаскивать объект мышью. 

Сначала я просто засекал событие mousemove, вычислял разность между старыми и новыми координами. Полученный вектор проецировал и пытался прибавить к позиции объекта. Результат был в принципе правильным, вот только масштабы были не те. Ни скорость, ни размах перемещения не годились в принципе. Что и понятно. После процеирования, позиции вектора или сам вектор смещения попадают на дальнуюю плоскость отсечения. Она огромна. Нормализованная длина вектора также огромна, зачастую, она соот-ет размерам самих объектов. Попытки взять длину экранного вектора также не привели ни к чему хорошему. 

Тогда я надумал найти плоскость, параллельную плоскости проецирования камеры, и находящующуюся между дальней и ближней плоскостью отсечения. И потом уже катать сферу по этой плоскости. 


=========


Наконец, я придумал так. Таскать объекты мышью по некоей плоскости, которая будет параллелльна ближней и дальней плоскостям и располагаться между ними. Нормалью этой плоскости будет вектор "вперёд", вектор направления взгляда камеры. Скалярное произведение с ним даёт расстояние от плоскости до начала координат. Таким образом мы получаем уравнение плоскости. Назовём её "drag_plane"

Дальше мы получаем из экранных координат луч, исходящий из камеры и идущий через трёхмерное пространство. Мы ищем его пересечение с drag_plane. Перемещаем таскаемый оъбъект в это место. Всё. 