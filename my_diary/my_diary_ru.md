Всё началось с того, что я захотел сделать систему частиц, чтобы вспомнить старые добрые времена. Частицы это просто массив однотипных данных, включаяющих вектора скорости, положения, цвета, размеры и проч. Вычисляются силы, действующие на частицы, всё это интегрируется и потом загоняется в шейдеры, где рисуется точками. 

Я нашёл баг в библиотеке three.js, написал issue и предложил разработчикам исправить его. Это было сделано нормально. 

Затем мне захотелось сделать редактор частиц. Мне было лень работать напрямую с javascript или писать свой велосипед. Я использовал один из новомодных фреймвоков, это был Vue. Он сработал достаточно хорошо, хотя и были нарекания.

Потом я добавил простую система анимации. С помощью примесей к объектам THREE.Object3D добавляется метод update и набор объектов анимаций со своим методом update, принимающих прошедшее время. Это позволяет сделать простенькую анимацию вроде вращений, растяжений, перемещений, управляемых таймером. 

Потом я захотел сохранить сцену. Это было нелегко. Система toJSON, встроенная в THREE едва ли способна к расширению. Это плохой дизайн. Она спроецирована "фрактально", каждый объект может выдавать готовое описание сцены. Это здорово, да. Но в целом это невозможно расширять и поддерживать. Я кое-как написал свой Scene_Serializer на основе костылей и примесей к объекту  THREE.Object3D. Это ужасно и надо заменить. Но кое-как оно работает. 

Меня просто добивают эти постоянные асинхронности и необходимость иметь кучу функций-обраток, вызываемых при успехе или ошибке, и которые выстраиваются в длинные цепочки. Введение promise не делает систему лучше. Она всё равно останется говном. Единственное решение - уменьшить число асинхронных действий. Например, получать из сети не кучу связанной информации, а помещать всю взаимосвязанную информацию в один блоб с жёсткой структурой. 

Потом я попытался сделать мой проект модульным. Необходимость в этом назрела. Я использовал сначала rollup, затем webpack. Я был страшно разочарован! Обе этих приблуды дублируют модули! У меня сложный проект, в нём есть много модулей, одни импортируют другие, другие - третьи и т.д. Возможно, какие-то модули импортируются многократно. Я не могу уследить за всем. Я даже понятия не имею, есть ли там круговые ссылки. Хотя и старался не допустить этого. В нормальных языках есть средства, чтобы избежать дублирования включённых файлов. В C/C++ используются директивы препроцессора 

#ifndef _MODULE_NAME_
#define _MODULE_NAME_

big pyle of code

#endif

На уровне файлов obj за этим следит компоновщик. 

В Дельфи/Паскале за этим следит компилятор и компоновщик. 

Я пришёл в отчаяние, и тут меня осенило. Возможно, прооблема в регистрах символов. Windows не различает размеры букв в именах файлов. Заглавные и строчные буквы она считает одним и тем же. Для неё File и file это одна сущность. Наоборот, Unix-like системы считают такие файлы двумя разными сущностями. Я работаю под Windows. Часть имён файлов у меня начинанась с заглавных букв, а пути в операторах import были с маленьких букв. Иногда было наоборот. Rollup и Webpack это кушали, но в ответ создавали по две разные копии импортируемых файлов. Возможно,это решение проблемы, мучающий многих людей долгие годы! Может, надо им сообщить? 

Я сообщил, мне сказали, что это нормальное поведение node.js и ничего делать не надо. Ладно.


К сожалению, на этом злоключения на закончились. Webpack поломал работу моего механизма фабрики классов, Register Classes. Это была хорошая идея. Каждый класс вносится в таблицу пар вида (имя класса, функция-конструктор). Когда мы загружаем данные из json, то просто берём имя класса из поля type, получаем конструктор из таблицы и строим объект. 

В результате я получил ЭТО


Object { Base_Animation: Base_Animation(), Euler_Animation: Euler_Animation(), Particle_Emitter: Particle_Emitter(), Constant_Force: Engine</Particle_Forces.Constant_Force(), Particle_Affector: Particle_Affector(), Force_Affector: Force_Affector(), function Custom_Emitter() {
    __WEBPACK_IMPORTED_MODULE_1__particle_emitter_js__["a" /* Particle_Emitter */].apply(this, arguments);
}: "Custom_Emitter", function Custom_Affector() {
    __WEBPACK_IMPORTED_MODULE_1__particle_affector_js__["a" /* Particle_Affector */].apply(this, arguments);
    this.custom_func = function dummy() {
        return true;
    };
}: "Custom_Affector", Cone_Emitter: Cone_Emitter(), Star_Dust_Emitter: Star_Dust_Emitter(), ещё 1… }

Надо быть осторожнее. Но в целом работает, если делать создание класса в пределах одного модуля и передавать его на сохранение уже в готовом виде. Нельзя отдавать создание класса в другой модуль, как я делал с My_Lib.create_class. Хотя это экономит время.



** Минус против Vue

Значение элемента select можно установить только через v-model="name". Привязка v-bind="name" не действует. Элемент не реагирует на её изменения.


** Перетаскивание

